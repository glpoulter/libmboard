/* $Id$ */
/*!
 * \file mboard-parse-memlogdb.c
 * 
 * \code
 *      Author: Lee-Shawn Chin 
 *      Date  : Sep 2008 
 *      Copyright (c) 2008 STFC Rutherford Appleton Laboratory
 * \endcode
 * 
 * \brief Program to convert Memory Log output to gnuplot script/data
 * 
 * Reads in <i>memlog-*.db</i> sqlite database files generated by libmboard 
 * (configured with \c --enable-memlog) and produces the corresponding 
 * gnuplot script and data files.
 * 
 * \note We use GNU's argp.h to parse input arguments and options. It 
 *       provides hierarchical argument parsing (layered over getopt). 
 */

/* splint directives to silence acknowledged warnings */
/*@-fullinitblock -retvalother -unrecog@*/


#ifdef HAVE_CONFIG_H
#include "mb_config.h"
#endif

#include <argp.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "sqlite3.h"

/* ------ filename params ------ */

/*! \brief Prefix of memlog database files */
#define MEMLOGDB_PREFIX "memlog-"

/*! \brief Prefix of output files */
#define OUTFILE_PREFIX "memlog_parsed"

/*! \brief Prefix of temporary files used to store list of labels */
#define TEMPFILE "memlog_tempfile"

/*! \brief Maximum length of file/directory names */
#define FILENAME_MAXLEN 1024

/*! \brief Maximum length of temporary strings */
#define LINE_MAX 1024


/* ------ sql params ------ */

/*! \brief SQL SELECT statement used to retrieve memory usage data */
#define SQL_SELECT_USAGE  "SELECT ts,allocated FROM mem_usage ORDER BY ts;"

/*! \brief SQL SELECT statement used to retrieve label data */
#define SQL_SELECT_MSTONE "SELECT ts,label FROM milestone ORDER BY ts;"


/* ------ macros for printing output ------ */

/*! \brief Macro for printing when not in silent/quiet mode */
#define REPORT if(arguments.silent==0) printf

/*! \brief Macro for printing when in verbose mode */
#define REPORTV if(arguments.verbose==1) printf


/* ------ GNUPLOT script params ------ */

/*! \brief GNUPLOT script var: Title */
#define GPLOT_TITLE  "Memory Usage"

/*! \brief GNUPLOT script var: x-axis label */
#define GPLOT_XLABEL "Elapsed time (Seconds)"

/*! \brief GNUPLOT script var: y-axis label */
#define GPLOT_YLABEL "Memory (Bytes)"

/*! \brief GNUPLOT script var: Prefix of description for "memory usage" line */
#define GPLOT_LINETITLE "Memory Usage of P"

/*! \brief GNUPLOT script var: Prefix of description for "max memory used" line */
#define GPLOT_MAXTITLE  "Maximum memory Used by P"

/*! \brief GNUPLOT script header */
#define GPLOT_HEADER "#!/usr/bin/env gnuplot\n\
# Generated by mboard-parse-memlogdb\n\
reset\n\
\n\
# Place legend below the chart \n\
set key below \n\
\n\
# Dummy function for drawing horizontal lines \n\
f(x) = x \n\
"
/*! \brief GNUPLOT script: statements to generate PNG output */
#define GPLOT_PNGOUT "\n\
# write chart to as PNG \n\
set term png  \n\
set output '%s.png' \n\
"

/*! \brief GNUPLOT script: statements to mark chart with labels */
#define GPLOT_MSTONE "\n\
# Mark milestones with vertical lines \n\
set grid x2tics \n\
set x2tics("

/* ----------- argp stuff for parsing input args and options ----------- */

/*! \brief ARGP var: program version */
const char *argp_program_version = "MessageBoard Library - Memlog Parser v0.1";

/*! \brief ARGP var: bug report address */
const char *argp_program_bug_address = "<shawn.chin@stfc.ac.uk>";

/*! \brief ARGP var: documentation string */
static char doc[] = "\n"
        "Parses sqlite3 DB files produced by memlog enabled versions of libmboard.\n\n"
        "Executing 'mboard-parse-memlogdb 2' will parse files:\n"
        " * memlog-0_of_1.db\n"
        " * memlog-1_of_1.db\n"
        "to produce :\n"
        " * memlog_parsed_0.dat\n"
        " * memlog_parsed_1.dat\n"
        " * memlog_parsed.gnuplot\n\n"
        "More options:";

/*! \brief ARGP var: accepted arguments */
static char args_doc[] = "NUM_PROC_USED";

/*! \brief ARGP var: accepted options */
static struct argp_option options[] = {
  {"verbose",  'v', 0,      0,  "Produce verbose output" , 0},
  {"quiet",    'q', 0,      0,  "Don't produce any output", 0 },
  {"silent",   's', 0,      OPTION_ALIAS },
  {"directory",'d', "DIR", 0, "Look for db files in DIR" , 0},
  { 0 }
};

/*! \brief ARGP: datatype used to interact with parse_opt() */
struct arguments
{
  char *args[1];
  int silent, verbose;
  char *input_dir;
};

/* ARGP parse function. Doxygen comment declared further down this file */
static error_t parse_opt(int key, char *arg, struct argp_state *state);

/*! \brief ARGP: Instance of parser */
static struct argp argp = { options, parse_opt, args_doc, doc };

/* ------ argp config arguments ------ */

/*! \brief var for interacting with parse_opt() */
struct arguments arguments;

/*! \brief number of processors used in simulation */
int procs;

/*! \brief array of maximum memory used per processor */
int *maxmem;

/*! \brief maximum timestamp (end of simulation) */
double maxts;

/* --- function prototypes --- */
int check_input_files(void);
int write_dat_files(void);
int write_gnuplot_script(void);

/* ----------- Start main program ----------- */

/*! 
 * \brief main function called at start of program 
 * \param[in] argc Input argument count
 * \param[in] argv Array of input arguments
 * \return Integer return code
 */
int main(int argc, char **argv) {
  
    int i, rc;
    
    /* Default values. */
    arguments.silent    = 0;
    arguments.verbose   = 0;
    arguments.input_dir = ".";
    
    /* Parse our arguments */
    argp_parse (&argp, argc, argv, 0, 0, &arguments);
    
    /* --silent and --quiet have preceedence over --verbose */
    if (arguments.silent == 1) arguments.verbose = 0;
    
    /* check that NUM_PROC_USED is a positive integer */
    procs = atoi(arguments.args[0]);
    if (procs < 1)
    {
        fprintf(stderr, "ERROR: Input argument NUM_PROC_USED must be a positive integer\n");
        fprintf(stderr, "       For usage information, run %s --help\n", argv[0]);
        return 1;
    }
    
    /* initialise temp array and vars */
    maxts = 0.0;
    maxmem = (int *)malloc(sizeof(int) * procs);
    for (i = 0; i < procs; i++) maxmem[i] = 0;
    
    /* check that all input files are readable */
    rc = check_input_files();
    if (0 != rc) return rc;
    
    /* read DB and write our dat files */
    rc = write_dat_files();
    if (0 != rc) return rc;
    
    /* write gnuplot script */
    rc = write_gnuplot_script();
    if (0 != rc) return rc;
    
    /* free temp array */
    free(maxmem);
    
    REPORT("\nOutput files written to:\n");
    for (i = 0; i < procs; i++)
    {
        REPORT(" * %s_%d.dat\n", OUTFILE_PREFIX, i);
    }
    REPORT(" * %s.gnuplot\n\n", OUTFILE_PREFIX);
    
    REPORT("Now run 'gnuplot %s.gnuplot' to generate memory usage chart\n", OUTFILE_PREFIX);
    return 0;
}

/*!
 * \brief Writes out gnuplot script based on info gleaned from input <i>*.db</i> files
 * \return Integer return code
 * 
 * This routine must be called after write_dat_files() as it uses variables and
 * files created by the function.
 *
 */
int write_gnuplot_script(void) {
    
    int i, f, rc;
    FILE *file, *tempfile;
    char filename[FILENAME_MAXLEN];
    char line[LINE_MAX];
    
    REPORTV("\nGenerating Gnuplot script\n");
    
    snprintf(filename, FILENAME_MAXLEN, "%s.gnuplot", OUTFILE_PREFIX);
    REPORTV("Creating file %s\n", filename);
    if (!(file = fopen(filename, "w")))
    {
        fprintf(stderr, "ERROR: Unable to create file %s\n", filename);
        return 1;
    }
    
    REPORTV(" * writing script header\n");
    fprintf(file, GPLOT_HEADER);
    
    REPORTV(" * gnuplot should generate PNG output\n");
    snprintf(line, LINE_MAX, GPLOT_PNGOUT, OUTFILE_PREFIX);
    fprintf(file, line);
    
    REPORTV(" * set xrange to 0 - %f\n", maxts);
    fprintf(file, "\nset xrange[0:%f]\n", maxts);
    
    REPORTV(" * annotating milestones in chart\n");
    fprintf(file, GPLOT_MSTONE);
    f = 0;
    for (i = 0; i < procs; i++)
    {
        snprintf(filename, FILENAME_MAXLEN, "%s.%d", TEMPFILE, i);
        REPORTV("   - loading label file: %s ... ", filename);
        if (!(tempfile = fopen(filename, "r")))
        {
            REPORTV("[FAIL]\n");
            fprintf(stderr, "ERROR: Unable to load file %s\n", filename);
            return 1;
        }
        REPORTV("[OK]\n");
        
        
        while (fgets(line, LINE_MAX, tempfile) != NULL)
        {
            
            /* remove \n */
            line[strlen(line) - 1] = '\0';

            /* write delimiter (comma) */
            if (f == 0) f = 1;
            else fprintf(file, ", ");
            
            /* copy label entry */
            fprintf(file, line);
        }
        
        REPORTV("   - deleting label file: %s ... ", filename);
        fclose(tempfile);
        rc = remove(filename);
        if (rc == 0) 
        {
            REPORTV("[OK]\n");
        }
        else 
        {
            REPORTV("[FAIL]\n");
        }
        
    }
    fprintf(file, ")\n");
    
    fprintf(file, "\n# Title and labels for the axes\n");
    fprintf(file, "set title '%s'\n", GPLOT_TITLE);
    REPORTV(" * set chart title to '%s'\n", GPLOT_TITLE);
    fprintf(file, "set xlabel '%s'\n", GPLOT_XLABEL);
    REPORTV(" * set x-axis label to '%s'\n", GPLOT_XLABEL);
    fprintf(file, "set ylabel '%s'\n", GPLOT_YLABEL);
    REPORTV(" * set y-axis label to '%s'\n", GPLOT_YLABEL);
    
    fprintf(file, "\n# Marking max memory used per proc\n");
    for (i = 0; i < procs; i++)
    {
        REPORTV(" * marking max memory usage for each proc %d\n", i);
        snprintf(line, LINE_MAX, "set label '%d' at 0,%d right tc lt %d front\n", 
                 maxmem[i], maxmem[i], i);
        fprintf(file, line);
    }
    
    fprintf(file, "\nplot \\\n");
    for (i = 0; i < procs; i++)
    {
        snprintf(filename, FILENAME_MAXLEN, "%s_%d.dat", OUTFILE_PREFIX, i);
        REPORTV(" * plotting line for datafile %s\n", filename);
        fprintf(file, "'%s' title '%s%d' with lines, \\\n", 
                filename, GPLOT_LINETITLE, i);
    }
    for (i = 0; i < procs; i++)
    {
        REPORTV(" * plotting line for max memory used by P%d\n", i);
        fprintf(file, "f(%d) title '%s%d (%d Bytes)' with lines",
                maxmem[i], GPLOT_MAXTITLE, i, maxmem[i]);
        if (i == (procs - 1)) fprintf(file, "\n");
        else fprintf(file, ", \\\n");
    }
    
    snprintf(filename, FILENAME_MAXLEN, "%s.png", OUTFILE_PREFIX);
    fprintf(file, "\nprint 'Memory usage chart written to %s", filename);
    
    /* close file */
    fclose(file);
    
    return 0;
}

/*!
 * \brief Reads in the <i>*.db</i> and writes out the corresponding <i>*.dat</i> files
 * \return Integer return code
 * 
 * This function assumes that all the required <i>*.db</i> are available and readable.
 * 
 * For each db file, it writes out a corresponding data file in a format that 
 * gnuplot understands. It also writes out the label+timestamp data into a temporary
 * file to be used alter by write_gnuplot_script().
 * 
 */ 
int write_dat_files(void) {
    
    FILE *file, *file2;
    sqlite3 *db;
    sqlite3_stmt *stmt, *stmt2;
    char filename[FILENAME_MAXLEN];
    char filename2[FILENAME_MAXLEN];
    char filename3[FILENAME_MAXLEN];
    char label_annotated[FILENAME_MAXLEN];
    const unsigned char *label;
    int i, rc, allocated;
    double ts;
    
    for (i = 0; i < procs; i++)
    {
        REPORTV("\nProcessing output from processor %d\n", i);
        
        /* derive filename of db */
        snprintf(filename, FILENAME_MAXLEN, "%s/%s%d_of_%d.db", 
                arguments.input_dir, MEMLOGDB_PREFIX, i, procs - 1);
        
        /* defive filename of output file */
        snprintf(filename2, FILENAME_MAXLEN, "%s_%d.dat", OUTFILE_PREFIX, i);
        
        /* defive filename of output file */
        snprintf(filename3, FILENAME_MAXLEN, "%s.%d", TEMPFILE, i);
        
        /* open database */
        REPORTV("Loading sqlite3 database: %s ... ", filename);
        rc = sqlite3_open_v2(filename, &db, SQLITE_OPEN_READONLY, NULL);
        if (rc != SQLITE_OK)
        {
            REPORTV("[FAIL]\n");
            fprintf(stderr, "ERROR: Unable to open db %s\n", filename);
            return rc;
        }
        REPORTV("[OK]\n");
        
        /* open file for writing */
        REPORTV("Creating output file: %s ... ", filename2);
        if (!(file = fopen(filename2, "w")))
        {
            REPORTV("[FAIL]\n");
            fprintf(stderr, "ERROR: Unable to create file %s for writing\n", filename2);
            return rc;
        }
        if (!(file2 = fopen(filename3, "w")))
        {
            REPORTV("[FAIL]\n");
            fprintf(stderr, "ERROR: Unable to create temp file %s for writing\n", filename3);
            return rc;
        }
        REPORTV("[OK]\n");
        
        /* precompile query */
        REPORTV("Precompiling sqlite3 SELECT queries ... ");
        rc = sqlite3_prepare(db, SQL_SELECT_USAGE, -1, &stmt, NULL);
        if (rc != SQLITE_OK)
        {
            REPORTV("[FAIL]\n");
            fprintf(stderr, "ERROR: Failed to precompile sqlite3 SELECT query.\n");
            return rc;
        }
        rc = sqlite3_prepare(db, SQL_SELECT_MSTONE, -1, &stmt2, NULL);
        if (rc != SQLITE_OK)
        {
            REPORTV("[FAIL]\n");
            fprintf(stderr, "ERROR: Failed to precompile sqlite3 SELECT query.\n");
            return rc;
        }
        REPORTV("[OK]\n");
        
        /* retrieve data from db */
        REPORT("Converting memlog data for P%d : ... ", i);
        while(sqlite3_step(stmt) == SQLITE_ROW) 
        {
            ts = sqlite3_column_double(stmt, 0);
            allocated = sqlite3_column_int(stmt, 1);
            
            /* update maxmem array */
            if (allocated > maxmem[i]) maxmem[i] = allocated;
            
            /* update maxts */
            if (ts > maxts) maxts = ts;
            
            fprintf(file, "%f\t%d\n", ts, allocated);
        }
        while(sqlite3_step(stmt2) == SQLITE_ROW) 
        {
            ts    = sqlite3_column_double(stmt2, 0);
            label = sqlite3_column_text(stmt2, 1);
            snprintf(label_annotated, FILENAME_MAXLEN, "%s%d", (char *)label, i);
            fprintf(file2, "'%s' %f\n", label_annotated, ts);
        }
        REPORT("[OK]\n");
        
        /* close database */
        REPORTV("Closing database: %s ... ", filename);
        sqlite3_finalize(stmt);
        sqlite3_finalize(stmt2);
        rc = sqlite3_close(db);
        if (rc != SQLITE_OK)
        {
            REPORTV("[FAIL]\n");
            fprintf(stderr, "ERROR: Problem encountered while closing db %s\n", filename);
            return rc;
        }
        REPORTV("[OK]\n");
        
        /* close outfile */
        REPORTV("Closing file: %s ... ", filename2);
        fclose(file);
        fclose(file2);
        REPORTV("[OK]\n");
        
    }
    
    return 0;
}

/*!
 * \brief Checks that all the expected <i>*.db</i> files are available and readable 
 * 
 * Perform a simple check by opening the files for reading, then closing them.
 * 
 */ 
int check_input_files(void) {
    
    int i;
    FILE *file;
    char filename[FILENAME_MAXLEN];
    
    REPORTV("\nSearching for input files:\n");
    
    for (i = 0; i < procs; i++)
    {
        snprintf(filename, FILENAME_MAXLEN, "%s/%s%d_of_%d.db", 
                arguments.input_dir, MEMLOGDB_PREFIX, i, procs - 1);
        if ((file = fopen(filename, "r")) != NULL)
        {
            REPORTV(" * Found file %s\n", filename);
            fclose(file);
        }
        else
        {
            fprintf(stderr, "ERROR: Unable to read file %s\n", filename);
            return 1;
        }
    }
    
    return 0;
}

/*!
 * \brief Function used to process input arguments
 * \return Error code (\c error_t)
 * 
 * This function is called by <tt>argp_parse()</tt> on each input argument
 */
static error_t parse_opt (int key, char *arg, struct argp_state *state)
{
    /* Get the input argument from argp_parse, which we
     * know is a pointer to our arguments structure. 
     */
    struct arguments *arguments = state->input;

    switch (key)
    {
        case 'q':
        case 's':
            arguments->silent = 1;
            break;
            
        case 'v':
            arguments->verbose = 1;
            break;
            
        case 'd':
            arguments->input_dir = arg;
            break;
            
        case ARGP_KEY_ARG:
            if (state->arg_num >= 1)
                argp_usage(state); /* Too many arguments. */
            arguments->args[state->arg_num] = arg;
            break;
    
        case ARGP_KEY_END:
            if (state->arg_num < 1)
                argp_usage(state); /* Not enough arguments. */
            break;
    
        default:
            return ARGP_ERR_UNKNOWN;
    }
    
    return 0;
}

